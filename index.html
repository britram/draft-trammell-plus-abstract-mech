<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Abstract Mechanisms for a Cooperative Path Layer under Endpoint Contol</title>

<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc, ul.toc ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
/*]]>*/</style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Mechanism Definitions"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Sender-to-Path Declarations"/>
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Path-to-Receiver Declarations with Feedback"/>
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Direct Path-to-Sender Declarations"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Technical Considerations"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Cryptographic Context Bootstrapping"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Adding Integrity and Confidentiality Protection Along the Path"/>
<link href="#rfc.section.4" rel="Chapter" title="4 IANA Considerations"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Security Considerations"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Acknowledgments"/>
<link href="#rfc.references" rel="Chapter" title="7 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A Open Issues and Discussion Points"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.1 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Trammell, B." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-trammell-plus-abstract-mech" />
  <meta name="dct.issued" scheme="ISO8601" content="2016-8-03" />
  <meta name="dct.abstract" content="This document describes the operation of three abstract mechanisms for supporting an explicitly cooperative path layer in the Internet architecture. Three mechanisms are described: sender to path signaling with receiver integrity verification; path to receiver signaling with confidential feedback to sender; and direct path to sender signaling." />
  <meta name="description" content="This document describes the operation of three abstract mechanisms for supporting an explicitly cooperative path layer in the Internet architecture. Three mechanisms are described: sender to path signaling with receiver integrity verification; path to receiver signaling with confidential feedback to sender; and direct path to sender signaling." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">PLUS BoF</td>
  <td class="right">B. Trammell</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">ETH Zurich</td>
</tr>
<tr>
  <td class="left">Intended status: Informational</td>
  <td class="right">August 03, 2016</td>
</tr>
<tr>
  <td class="left">Expires: February 4, 2017</td>
  <td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Abstract Mechanisms for a Cooperative Path Layer under Endpoint Contol<br />
  <span class="filename">draft-trammell-plus-abstract-mech</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document describes the operation of three abstract mechanisms for supporting an explicitly cooperative path layer in the Internet architecture. Three mechanisms are described: sender to path signaling with receiver integrity verification; path to receiver signaling with confidential feedback to sender; and direct path to sender signaling.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on February 4, 2017.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2016 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>2.   <a href="#rfc.section.2">Mechanism Definitions</a></li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Sender-to-Path Declarations</a></li>
<li>2.2.   <a href="#rfc.section.2.2">Path-to-Receiver Declarations with Feedback</a></li>
<li>2.3.   <a href="#rfc.section.2.3">Direct Path-to-Sender Declarations</a></li>
</ul><li>3.   <a href="#rfc.section.3">Technical Considerations</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Cryptographic Context Bootstrapping</a></li>
<li>3.2.   <a href="#rfc.section.3.2">Adding Integrity and Confidentiality Protection Along the Path</a></li>
</ul><li>4.   <a href="#rfc.section.4">IANA Considerations</a></li>
<li>5.   <a href="#rfc.section.5">Security Considerations</a></li>
<li>6.   <a href="#rfc.section.6">Acknowledgments</a></li>
<li>7.   <a href="#rfc.references">Informative References</a></li>
<li>Appendix A.   <a href="#rfc.appendix.A">Open Issues and Discussion Points</a></li>
<li><a href="#rfc.authors">Author's Address</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">The boundary between the network and transport layers was originally defined to be that between information used (and potentially modified) hop-by- hop, and that used end-to-end. End-to-end information in the transport layer is associated with state at the endpoints, but processing of network-layer information was assumed to be stateless.</p>
<p id="rfc.section.1.p.2">The widespread deployment of network address and port translation (NAPT) in the Internet has eroded this boundary. Since the first four bytes after the IP header or header chain &#8211; the source and destination ports &#8211; are frequently used for forwarding and access control decisions, and are routinely modified on path, they have de facto become part of the network layer. In-network functions that exploit the fact that transport headers are in cleartext in the absence of widespread deployment of IPsec <a href="#RFC4301">[RFC4301]</a> further erode this boundary.</p>
<p id="rfc.section.1.p.3">Evolution above the network layer and integrity of transport layer functions is only possible if this layer boundary is reinforced. Asking on-path devices nicely not to muck about in the transport layer and below &#8211; stating in an RFC that devices on path MUST NOT use or modify some header field &#8211; has not proven to be of much use here. A new approach is necessary, consisting of cryptographic integrity protection of network and transport layer headers which the endpoints choose to expose to the path, and cryptographic confidentiality protection of transport layer headers not to be exposed.</p>
<p id="rfc.section.1.p.4">We define the &#8220;path layer&#8221; to consist of the headers and associated functions that are explicitly exposed to devices along the path in this scheme. This document describes three abstract mechanisms for implementing path layer communications. The first principles in the design of these mechanisms are endpoint control, signaling transparency, and support of arbitrary relationships between endpoints and path devices.</p>
<p id="rfc.section.1.p.5">The principle of endpoint control means that all signaling, even from the path, is initiated by a sending endpoint, allowing a sending endpoint to opt into or out of path layer communications as it sees fit.</p>
<p id="rfc.section.1.p.6">The principle of signaling transparency means that at least the semantic type of all signals using these mechanisms must be visible to all path elements.  This makes it possible for users and network operators to use traffic inspection to observe what is being signaled. As a last resort, users and networks wishing to limit signaling using these mechanisms can simply drop packets containing signals they would prefer not to have sent.</p>
<p id="rfc.section.1.p.7">The principle of arbitrary relationship means that the basic mechanisms do not require any trust or cryptographic state between endpoints and path elements to function, though integrity protection and confidentiality for communication with path elements can be layered over these mechanisms; definition of key exchange and cryptographic protocols for this layering is out of scope for this document, however.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#mechanism-definitions" id="mechanism-definitions">Mechanism Definitions</a></h1>
<p id="rfc.section.2.p.1">Three abstract mechanisms suffice to implement in-band path layer communications, given our first principles. First, a sender can make declarations about itself or about traffic it is sending to devices along the path, relying on the receiver to verify integrity of the declaration. Second, a sender can allow path elements to make declarations about themselves or their treatment of given traffic, by creating space for the path elements to do so. In this case, the integrity of the presence, type, and size of this space is verified by the receiver, but not the content of the declaration made by the path. Third, a path element can make a declaration about a dropped packet back to the sender of that packet.</p>
<p id="rfc.section.2.p.2">These mechanisms are described in an implementation-independent way; however, there are a few basic assumptions made by the design:</p>
<p/>

<ul>
  <li>The mechanisms can add information to selected packets in a communication between two endpoints.</li>
  <li>The mechanisms can use a shared secret between the two endpoints provided by some upper layer.</li>
  <li>The confidentiality and integrity of upper layer&#8217;s headers and payload are cryptographically protected by the upper layer.</li>
  <li>The declarations carried by the mechanisms can be expressed in terms of key- value pairs, such that the type and semantic meaning of the declaration are completely defined by the key. The mechanisms don&#8217;t necessarily need to be implemented using a generic key-value framing (e.g. CBOR <a href="#RFC7049">[RFC7049]</a>); the key can be implied by a position in a defined packet header.</li>
</ul>
<h1 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> <a href="#sectxpath" id="sectxpath">Sender-to-Path Declarations</a></h1>
<p id="rfc.section.2.1.p.1">To make a declaration about a packet or flow to all path elements, the sender adds a key-value pair to a packet within the flow. The fact that this is a sender-to-path declaration is part of the definition of the key. Multiple declarations can appear in a single packet. All the declarations within a packet, together with other transport and network layer information which must not be modified by the path, are protected by a message authentication code (MAC) sent along with the packet, generated with a key derived from a secret known only to the endpoints.</p>
<p id="rfc.section.2.1.p.2">The receiver then verifies the MAC on receipt. Verification failure implies an attempt to modify the header used by this mechanism, and therefore must cause the transport association to reset.</p>
<p id="rfc.section.2.1.p.3">This arrangement is illustrated in <a href="#figtxpath">Figure 1</a>.</p>
<div id="rfc.figure.1"/>
<div id="figtxpath"/>
<pre>
[imagine some gratuitously colorful SVG here]

</pre>
<p class="figure">Figure 1: Sender to Path Declaration</p>
<h1 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a> <a href="#secpathrx" id="secpathrx">Path-to-Receiver Declarations with Feedback</a></h1>
<p id="rfc.section.2.2.p.1">To allow one or more path elements to make a declaration about itself with respect to a packet or a flow to the receiver, the sender adds a key-value pair to a packet within the flow. The fact that this is a path-to-receiver declaration is part of the definition of the key. Further, the value has a fixed length of N bytes (which my also be part of the definition of the key).  Path-to-receiver declarations may be combined in a packet with sender-to-path declarations as in <a href="#sectxpath">Section 2.1</a>, and are covered by the same MAC. However, when calculating the MAC for a path-to-receiver declaration, its value is assumed to be an N-byte array of zeroes. The MAC therefore protects the presence of the key and the length of the value, but not its content.</p>
<p id="rfc.section.2.2.p.2">The initial value of a path-to-receiver declaration is up to the sender, and is generally defined by the declaration itself. The behavior of a path element in filling in a path-to-receiver declaration given which value is already present is also part of the declaration defintion. Declarations may accumulate by some operation (e.g., max, min, sum for measurement declarations), be determined by the first or last path element, or be addressed to a specific path element to fill in.</p>
<p id="rfc.section.2.2.p.3">This arrangement is illustrated in <a href="#figpathrx">Figure 2</a>.</p>
<div id="rfc.figure.2"/>
<div id="figpathrx"/>
<pre>
[imagine some gratuitously colorful SVG here]

</pre>
<p class="figure">Figure 2: Path to Receiver Declaration</p>
<p id="rfc.section.2.2.p.4">This mechanism allows the sender to allow the receiver to receive path declarations. However, if it is the sender that needs to know the final result of the path declaration, this can be fed back to the sender over an encrypted channel. Depending on the characteristics of the upper layer, this encrypted channel can either be provided by the upper layer, or be provided by the layer implementing the mechanisms, using a key derived from the same secret known only to the endpoints used to generate the MAC. The fact that a path-to- receiver declaration should be fed back to the sender is part of the definition of the key.</p>
<p id="rfc.section.2.2.p.5">This arrangement is illustrated in <a href="#figfeedback">Figure 3</a>.</p>
<div id="rfc.figure.3"/>
<div id="figfeedback"/>
<pre>
[imagine some gratuitously colorful SVG here]

</pre>
<p class="figure">Figure 3: Receiver Feedback</p>
<h1 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3.</a> <a href="#secpathtx" id="secpathtx">Direct Path-to-Sender Declarations</a></h1>
<p id="rfc.section.2.3.p.1">Path-to-receiver declaration is impossible if a path element will drop a packet. In order to allow a path element to provide information about why a packet was dropped, it can send back a packet containing only a path-to-sender declaration. The fact that this is a direct path-to-sender declaration is part of the definition of the key. A path-to-sender declaration packet can only contain path-to-sender declarations. Since in the general case the path element has no shared secret with which to generate a MAC, this declaration cannot be integrity protected.</p>
<p id="rfc.section.2.3.p.2">In order for a path-to-sender declaration to traverse any network address translation (NAT) function along the path, the path element must send the packet with the IP addresses and transport/encapsulation layer ports reversed.</p>
<p id="rfc.section.2.3.p.3">The sender must indicate it is willing to receive path-to-sender declarations, and this indication must include some nonce or other identifier that is hard to guess by devices not on path, which is returned with the path-to-sender declaration to identify the packet to which the declaration applies.</p>
<p id="rfc.section.2.3.p.4">Only one path-to-sender declaration packet may be sent per dropped packet; this mitigates the abuse of this mechanism for executing amplified reflection attacks.</p>
<p id="rfc.section.2.3.p.5">This arrangement is illustrated in <a href="#figpathtx">Figure 4</a>.</p>
<div id="rfc.figure.4"/>
<div id="figpathtx"/>
<pre>
[imagine some gratuitously colorful SVG here]

</pre>
<p class="figure">Figure 4: Direct Path to Sender Declarations</p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#technical-considerations" id="technical-considerations">Technical Considerations</a></h1>
<p id="rfc.section.3.p.1">A few details must be considered in the implementation of the mechanisms described above; some are general, and some apply only in specific circumstances. They are described in the subsections below.</p>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#bootcrypto" id="bootcrypto">Cryptographic Context Bootstrapping</a></h1>
<p id="rfc.section.3.1.p.1">These mechanisms rely on an upper layer to establish a cryptographic context in order to establish a shared secret from which MAC keys can be derived. This cryptographic state may be established with each transport session or may be resumable across multiple transport sessions, depending on the upper layer&#8217;s design. If no context exists, though, the integrity of the declarations made via these mechanisms cannot be protected by MAC. We propose two possible solutions to this situation:</p>
<p/>

<ol>
  <li>The mechanisms can be implemented such that MAC is mandatory. In this arrangement, no sender-to-path and/or path-to-receiver declarations can be made until cryptographic context is bootstrapped. The vocabulary of declarations can therefore not include declarations that must be sent on the first packet.</li>
  <li>The mechanisms can be implemented such that the MAC is eventual. In this arrangement, sender-to-path declarations can be made before cryptographic context establishment, but are open to undetected modification along the path; path-to-receiver declarations are not allowed before cryptographic context establishment. A MAC for previous sender-to-path declarations must be sent after cryptographic context establishment; lack of receiving this MAC within a small number of packets from the sender is treated by the receiver as verification failure and leads to transport association reset.</li>
</ol>
<h1 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#adding-integrity-and-confidentiality-protection-along-the-path" id="adding-integrity-and-confidentiality-protection-along-the-path">Adding Integrity and Confidentiality Protection Along the Path</a></h1>
<p id="rfc.section.3.2.p.1">If a path element and the sender share some cryptographic context through some out-of-band means, sender to path declarations can also be integrity protected using a MAC generated by the sender and carried within the declaration itself.  In this case, if the path element fails to verify the MAC, it simply ignores the declaration.</p>
<p id="rfc.section.3.2.p.2">Similarly, if a path element and the receiver share some cryptographic context through some out-of-band means, path to receiver declarations can also be integrity protected using a MAC generated by the path element and carried within the declaration itself. The use of a MAC is part of the definition of the key. In this case, if the receiver fails to verify the MAC, it causes a transport association reset.</p>
<p id="rfc.section.3.2.p.3">This design pattern can also be used to address sender-to-path declarations to specific path elements: a declaration with an encrypted value is inherently addressed to only those path elements that possess the private or secret key to decrypt the value.</p>
<p id="rfc.section.3.2.p.4">In each of these cases, the presence of a MAC within the declaration value and/or encryption of the declaration value is part of the definition of the key. Further definition of mechanisms for building cryptographic protocols over these mechanisms is out of scope for this document.</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a></h1>
<p id="rfc.section.4.p.1">This document has no actions for IANA. A future document specifying a concrete implementation of these mechanisms and a vocabulary of declarations may create and modify an IANA registry of such declarations. [EDITOR&#8217;S NOTE: please remove this section at publication.]</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<p id="rfc.section.5.p.1">This document describes abstract mechanisms by which endpoints can share information about traffic flows with devices along the path, replacing the functions currently performed using traffic inspection of cleartext transport headers with explicit exposure when those headers are encrypted. The security and privacy threat posed by the application of these abstract mechanisms is a function of the vocabulary of declarations the endpoints use these mechanisms to expose. Care must be taken in defining this vocabulary, both to prevent the definition of declarations that are obviously threatening to privacy (e.g.  high-resolution, cleartext exposure of client device location) or insecure (e.g. exposure of session keys for transport headers and payload), as well as to minimize the potential for these declarations to be used as part of a device or user fingerprint for tracking and surveillance purposes.</p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#acknowledgments" id="acknowledgments">Acknowledgments</a></h1>
<p id="rfc.section.6.p.1">This work is supported by the European Commission under Horizon 2020 grant agreement no. 688421 Measurement and Architecture for a Middleboxed Internet (MAMI), and by the Swiss State Secretariat for Education, Research, and Innovation under contract no. 15.0268. This support does not imply endorsement.</p>
<p id="rfc.section.6.p.2">Thanks to Aaron Falk, Ted Hardie, Joe Hildebrand, Mirja Kuehlewind, Mark Nottingham, Natasha Rooney, and the participants at the PLUS BoF at IETF 96 in Berlin for the conversations leading to and informing the publication of this document. Thanks to Mark Nottingham for posing the questions that led to the design space for the mechanisms described herein.</p>
<h1 id="rfc.references"><a href="#rfc.references">7.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC4301">[RFC4301]</b>
      </td>
      <td class="top"><a>Kent, S.</a> and <a>K. Seo</a>, "<a href="http://tools.ietf.org/html/rfc4301">Security Architecture for the Internet Protocol</a>", RFC 4301, DOI 10.17487/RFC4301, December 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7049">[RFC7049]</b>
      </td>
      <td class="top"><a>Bormann, C.</a> and <a>P. Hoffman</a>, "<a href="http://tools.ietf.org/html/rfc7049">Concise Binary Object Representation (CBOR)</a>", RFC 7049, DOI 10.17487/RFC7049, October 2013.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> <a href="#open-issues-and-discussion-points" id="open-issues-and-discussion-points">Open Issues and Discussion Points</a></h1>
<p/>

<ul>
  <li><a href="#bootcrypto">Section 3.1</a> needs work: we need to be very clear about what happens when the upper layer doesn&#8217;t have any secrets from which a MAC can be derived, as well as how eventual or delayed MAC might work. Does PLUS needs to provide its own DH key exchange for opportunistic crypto when the upper layer doesn&#8217;t provide it? How does an encrypted transport on top of PLUS bootstrap itself: would this leak</li>
  <li>MAC failures in <a href="#sectxpath">Section 2.1</a> are presently defined to cause hard failure of the upper layer transport association. This is to defend against the misuse of the mechanisms for unauthorized in-band middlebox-to-middlebox signaling (since the upper layer&#8217;s integrity  and confidentiality protection prevents meddling in its own headers.) However, it may be sufficient for a PLUS receiver to signal to the upper layer that a MAC failure has occurred, so it can decide whether it wants to reset or not, while using the feedback channel to indicate to the sender that PLUS signaling is being meddled with on the path, so it can stop signaling anything.</li>
</ul>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Author's Address</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Brian Trammell</span> 
	  <span class="n hidden">
		<span class="family-name">Trammell</span>
	  </span>
	</span>
	<span class="org vcardline">ETH Zurich</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ietf@trammell.ch">ietf@trammell.ch</a></span>

  </address>
</div>

</body>
</html>
